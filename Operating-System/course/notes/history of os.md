# 实时笔记部分
 - 打孔机（无os，程序员直接操作硬件，）→NAA I/O（第一个操作系统，。实例：IBM 704）→ 
 - Mainframe(大型机)，Batch System批操作系统开始出现
 - Multiprogramming(多道程序设计，可以同时管理多个作业，实例：IBM System/360 + OS/360) → Timesharing(分时系统，Time Multiplexing将CPU时间分为小段，让每个人觉得自己在独占电脑；增加了交互性)，实例：MULTICS/UNIX
 - PC（个人电脑）,桌面操作系统，实例：Apple Mac，Microsoft Windos
 - 移动操作系统，用于手机平板，实例：IOS,Android
 - 
     - > 并行系统（Parallel OS）：解决单核 CPU 不够快 → 用多核/多处理器（如超级计算机 Cray）。
     - > 分布式系统（Distributed OS）：解决资源在不同计算机 → 用网络把它们虚拟成一个整体（如谷歌的集群操作系统 Borg）。
     - >实时系统（Real-Time OS）：解决安全与延迟问题 → 确保在毫秒级内响应（如飞机飞控系统、地铁信号系统）。



# History of Operating System
[课件内容]（https://github.com/UIT6/6UIT-learning-journal/blob/6906650b82d704b56ef3a07eedc883e6b4abe975/Operating-System/course/file/01-History-of-Operating-Systems.pdf）

## 1. 早期计算机（1940s–1950s）
- **没有操作系统**：用户直接操作硬件。  
- **输入输出**：一开始靠开关和灯光，后来是打孔卡、打印机。  
- **问题**：运行一个程序要人工准备很久；只能单用户；下一个程序由人手动调度；没有共享库或驱动。  

## 2. 第一个操作系统（1956）
- General Motors 为 **IBM 704** 开发的 **GM-NAA I/O**。  
- 作用：把一些常用的输入输出代码做成可复用库。  
- 特点：一个硬件厂商对应一个 OS，还没统一标准。  

## 3. 大型机 – 批处理系统（1950s）
- OS 存在于内存里，叫 **monitor**。  
- 程序（job）从打孔卡/磁带读入内存，OS 按作业控制指令运行。  
- 本质：就是一个 **运行时库 + 控制器**。  
- 问题：I/O 很慢，CPU 等待时浪费。  

## 4. 大型机 – 多道程序设计（1960s）
- 背景：出现了集成电路（IC），内存容量增加。  
- 思想：内存里放多个程序，CPU 在它们之间切换。  
- 好处：一个程序在 I/O 等待时，CPU 去算另一个 → CPU 利用率提高。  
- 这是现代 OS 的核心思想（多任务、多进程）。  

## 5. 大型机 – 分时系统（1960s–1970s）
- 早期多道程序还是批处理，没有交互，用户要等很久。  
- 新思路：把 CPU 时间切片（time slicing），多个用户通过终端共享一台机。  
- 用户感觉自己“独占”一台电脑。  
- 例子：**MULTICS**（后来影响了 UNIX）。  

## 6. 桌面操作系统（1980s）
- VLSI 技术让硬件更便宜 → 每人都有一台 PC。  
- 出现图形界面（GUI），提升了易用性。  
- 代表：**Windows, MacOS**。  
- 重点：关注用户体验，不再只强调 CPU 利用率。  

## 7. 移动操作系统（2000s）
- 针对手机和平板。  
- 多了传感器（GPS、陀螺仪）、无线网络。  
- 支持新型应用（比如 AR）。  
- 代表：**iOS, Android**。  

## 8. 并行操作系统
- 目标：在多核或多处理器上高效运行任务。  
- 提供任务分配、同步、通信。  
- 场景：超级计算机。  

## 9. 分布式操作系统
- 思路：把多台松散连接的计算机，通过网络抽象成“一台大机”。  
- 方便资源共享。  
- 代表：研究型系统 Amoeba，Google Borg（更实际）。  

## 10. 实时操作系统（RTOS）
- 要求：必须在固定时间内响应事件。  
- 场景：地铁系统、飞控、工厂、发电站。  
- 区分：硬实时（严格必须准时），软实时（如 PC 播放视频）。  


1. 最早的 OS 其实就是 **运行库 + 简单监控程序 (monitor)**，很“轻量”。  
2. **多道程序设计 (Multiprogramming)** 是现代 OS 的核心思想（CPU 不再浪费在 I/O 等待）。  
3. **分时系统 (Timesharing)** 是“从批处理 → 交互式计算”的转折点。  
4. 并行 / 分布式 / 实时 OS 是 **特定场景** 的进化，而不是普适的 OS 形态。  
